<html>
<head>
<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.9.0/p5.js"></script>
<!-- plein de collisions de globales, TODO faudra nettoyer -->
<script src="/app/pong/game.js"></script>
<script type="text/javascript">

  var buttonHeight = 30;
  var scalingWidth = 1.0;
  var scalingHeight = 1.0;
  
  // UI game
  var mouseY;
  function setup() {
    var canvas = createCanvas(windowWidth, windowHeight - buttonHeight);
    scalingWidth = windowWidth/width;
    scalingHeight = (windowHeight - buttonHeight)/height;
    canvas.parent('sketch-holder');
    mouseY = mouseY;
  }
  function windowResized() {
    resizeCanvas(windowWidth, windowHeight - buttonHeight);
    scalingWidth = windowWidth/width;
    scalingHeight = (windowHeight - buttonHeight)/height;
  }
  

  function scaleRect(x, y, xl, yl) {
    rect(
      x  * scalingWidth, y  * scalingHeight,
      xl * scalingWidth, yl * scalingHeight
    );
  }
  function unScaleHeight(y) {
    return y / scalingHeight;
  }
  function boxY(y) {
    return Math.min(windowHeight - buttonHeight, y)
  }
  
  var side;
  
  var lastAccurateDataTime;
  var lastInterpolationTime = 0;
  const MAX_INTERPOLATION_MS = 300;
  function draw() {
    
    var now = new Date().getTime();
    var deltatime;
    if (0 !== lastInterpolationTime) {
      deltatime = now - lastInterpolationTime;
    } else {
      deltatime = 0;
    }
    lastInterpolationTime = now;
    // client interpolation
    if (0 !== deltatime && lastAccurateDataTime && (now - lastAccurateDataTime < MAX_INTERPOLATION_MS)) {
      updateGame(deltatime);
    }
    
    background(255, 247, 240);
    fill(0, 0, 0);
    scaleRect(leftDistance , state.game.leftY  - racketHeight/2, racketWidth, racketHeight);
    scaleRect(rightDistance, state.game.rightY - racketHeight/2, racketWidth, racketHeight);
    fill(0, 0, 255);
    if (state.side) {
      if (state.side === 'left') {
        scaleRect(leftDistance, unScaleHeight(boxY(mouseY)) - racketHeight/2, racketWidth, racketHeight);
      } else if (state.side === 'right') {
        scaleRect(rightDistance, unScaleHeight(boxY(mouseY)) - racketHeight/2, racketWidth, racketHeight);
      }
    }
    fill(0, 0, 0);
    scaleRect(state.game.ballX - ballRadius, state.game.ballY - ballRadius, ballDiameter, ballDiameter);
    // draw se fait requestAnimationFramer? du coup on mettrait de l'interpolation ici?
        
  }
  
  // UI buttons
  function updateSide() {
    document.getElementById('side-chosen-left').style.borderStyle = null;
    document.getElementById('side-chosen-observe').style.borderStyle = null;
    document.getElementById('side-chosen-right').style.borderStyle = null;
    document.getElementById('side-chosen-' + state.side + '').style.borderStyle = 'inset';
  }
  function updateScoresAndCounts() {
    document.getElementById('side-chosen-left-text').innerHTML = 'Play as Left (score: ' + state.game.scoreLeft + ', users #: ' + state.user_count.countLeft + ')';
    document.getElementById('side-chosen-observe-text').innerHTML = 'Observe (users #: ' + state.user_count.countObserve + ')';
    document.getElementById('side-chosen-right-text').innerHTML = 'Play as Right (score: ' + state.game.scoreRight + ', users #: ' + state.user_count.countRight + ')';
  }
  

  // Network setup
  function processServerMessage(evt) {
    var msg = JSON.parse(evt.data);
    if (msg.table === 'ack_side') {
      state.side = msg.payload.side;
      updateSide();
    } else if (msg.table === 'game_out_to_client') {
      state.game = msg.payload;
      lastAccurateDataTime = new Date().getTime();
      updateScoresAndCounts();
    } else if (msg.table === 'user_count') {
      state.user_count = msg.payload;
      updateScoresAndCounts();
    } else {
      console.log('received msg of unknown table:');
      console.log(msg);
    }
  };
  
  var appName = window.location.pathname.replace('/app/', '').replace('/', '');
  var ws;
  
  function sendToServer(table, msg) {
    // TODO queuing? because si ws était pas prête, on drop
    if (ws && ws.readyState === WebSocket.OPEN) {
      var serverMsg = {
        intent : 'WRITE',
        table : appName + '.' + table,
        payload : msg
      };
      ws.send(JSON.stringify(serverMsg));
    }
  }
  
  function logEvent(evt) {
    console.log(evt);
  };
  
  function wsConnect() {
    var mypath = "/service"
    var wsUrl = "ws://" + window.location.host + mypath + "/ws";
    ws = new WebSocket(wsUrl);
    ws.onopen = logEvent;
    ws.onclose = logEvent;
    ws.onmessage = processServerMessage;
  }
  wsConnect();
  
  
  
  
  // Network business
  function chooseSide(e) {
    console.log(e);
    sendToServer('choose_side', {side : e});
  }
  
  var lastSentMouseY;
  function sendPosition() {
    var trueY = unScaleHeight(boxY(mouseY));
    if(lastSentMouseY !== trueY) {
      lastSentMouseY = trueY;
      sendToServer('write_y', {y : trueY});
    }
  }

  // TODO try the internal subscription mecanism
  function getGlobalPosition() {
    sendToServer('query_global_position', {now : '' + Date.now()});
  }
  
  setInterval(sendPosition, 40);
  setInterval(getGlobalPosition, 41);
  

</script>
</head>
<body style="margin: 0;">
  <div id="game">
    <div id="sketch-holder"></div>
    <div id="button-sides" style="display: flex;height: 30px;">
    
      <button id="side-chosen-left"    type="button" onclick="chooseSide('left');"    style="outline: none; flex-basis: 100%; width:100%;">
        <span id="side-chosen-left-text"   >Observe</span>
      </button>
      <button id="side-chosen-observe" type="button" onclick="chooseSide('observe');" style="outline: none; flex-basis: 100%; width:100%;border-style:inset;">
        <span id="side-chosen-observe-text">Observe</span>
      </button>
      <button id="side-chosen-right"   type="button" onclick="chooseSide('right');"   style="outline: none; flex-basis: 100%; width:100%;">
        <span id="side-chosen-right-text"  >Play as Right</span>
      </button>
    </div>
  </div>
</body>
</html>